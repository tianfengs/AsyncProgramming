异步编程系列文章4：《异步编程：轻量级线程同步基元对象》
http://www.cnblogs.com/heyuquan/archive/2013/01/10/2854311.html

随着.NET框架的进化，.NET4.0|.NET4.5又为我们带来了更多优化的同步基元选择。

### 一、基元用户模式构造、基元内核模式构造、混合构造
基元线程同步构造分为：基元用户模式构造和基元内核模式构造。

1. 基元用户模式构造

   应尽量使用基元用户模式构造，因为它们使用特殊的CPU指令来协调线程，这种协调发生硬件中，速度很快。

   用户模式构造有：volatile关键字、Interlocked静态类、Thread的VolatileWrite()与VolatileRead()方法。

2. 基元内核模式构造

   是Windows操作系统自身提供的。

   它们要求我们调用在操作系统内核中实现的函数，调用线程将从托管代码转换为本地用户模式代码，再转换为本地内核模式代码，然后还要朝相反的方向一路返回，会浪费大量CPU时间，同时还伴随着线程上下文切换，因此**尽量不要让线程从用户模式转到内核模式**。

   包含的内核模式构造有：EventWaitHandle(以及AutoResetEvent与ManualResetEvent)、Mutex、Semaphore。（另外：ReaderWriterLock）

3. 混合构造

   对于在一个构造上等待的线程，如果拥有这个构造的线程一直不释放它，则会出现：

   1)         如果是用户模式构造，则线程将一直占用CPU，我们称之为“活锁”。

   2)         如果是内核模式构造，则线程将一直被阻塞，我们称之为“死锁”。

   混合构造正是为了解决这种场景。其通过合并用户模式和内核模式实现：在没有线程竞争的时候，混合构造提供了基元用户模式构造所具有的性能优势。多个线程同时竞争一个构造的时候，混合构造则使用基元内核模式的构造来提供不“自旋”的优势。

   包含的有：Monitor\lock

   本节将给大家介绍.NET4.0中加入的混合结构：ManualResetEventSlim、SemaphoreSlim、CountdownEvent、Barrier、ReaderWriterLockSlim。

   混合结构优化的本质：**两阶段等待操作**

   > 线程上下文切换需要花费几千个周期(每当线程等待内核事件WaitHandle时都会发生)。我们暂且称其为C。假如线程所等待的时间小于2C(1C用于等待自身，1C用于唤醒)，则自旋等待可以降低等待所造成的系统开销和滞后时间，从而提升算法的整体吞吐量和可伸缩性。
   >
   > 在多核计算机上，当预计资源不会保留很长一段时间时，如果让等待线程以用户模式旋转数十或数百个周期，然后重新尝试获取资源，则效率会更高。如果在旋转后资源变为可用的，则可以节省数千个周期。如果资源仍然不可用，则只花费了少量周期，并且仍然可以进行基于内核的等待。这一旋转-等待的组合称为“两阶段等待操作”。

### 二、协作对象和自旋结构

在介绍.NET4.0新同步结构前，我们需要：

- 认识两个协作对象：CancellationTokenSource和cancellationToken。因为它们常常被用于混合结构中。Eg：使一个线程强迫解除其构造上的等待阻塞。

- 认识两个自旋结构：SpinWait和SpinLock

1. 协作式取消

   使用**CancellationTokenSource**创建一个或多个取消标记**CancellationToken**（cancellationToken可在线程池中线程或 Task 对象之间实现协作取消），然后将此取消标记传递给应接收取消通知的任意数量的线程或Task对象。当调用CancellationToken关联的CancellationTokenSource对象的 Cancle()时，每个取消标记(CancellationToken)上的IsCancellationRequested属性将返回true。异步操作中可以通过检查此属性做出任何适当响应。

   1. CancellationTokenSource相关API

      ```
      // 通知System.Threading.CancellationToken，告知其应被取消。
      public class CancellationTokenSource : IDisposable
      {
          // 构造一个CancellationTokenSource将在指定的时间跨度后取消。
          public CancellationTokenSource(int millisecondsDelay);
       
          // 获取是否已请求取消此CancellationTokenSource。
          public bool IsCancellationRequested { get; }
           
          // 获取与此CancellationTokenSource关联的CancellationToken。
          public CancellationToken Token { get; }
       
          // 传达取消请求。参数throwOnFirstException:指定异常是否应立即传播。
          public void Cancel();
          public void Cancel(bool throwOnFirstException);
          // 在此CancellationTokenSource上等待指定时间后“取消”操作。
          public void CancelAfter(int millisecondsDelay);
       
          // 创建一组CancellationToken关联的CancellationTokenSource。
          public static CancellationTokenSource CreateLinkedTokenSource(paramsCancellationToken[] tokens);
       
          // 释放由CancellationTokenSource类的当前实例占用的所有资源。
          public void Dispose();
          ……
      }
      ```

      - CancellationTokenSource.CreateLinkedTokenSource()方法: 
        - 将一组CancellationToken连接起来并创建一个新的CancellationTokenSource。
      -  CancellationTokenSource实例Cancel()方法做了什么：
        - 将CancellationTokenSource实例的IsCancellationRequested属性设置为true
        - 调用CancellationTokenSource实例的CreateLinkedTokenSource()注册的Cancel()委托回调
        - 调用CancellationToken实例的Register()注册的回调
        - 处理回调异常。（参数throwOnFirstException）
          - 若为Cancel()传递true参数，那么抛出了未处理异常的第一个回调方法会阻止其他回调方法的执行，异常会立即从Cancel()中抛出
          - 若为Cancel()传递false（默认为false），那么登记的所有回调方法都会调用。所有未处理的异常都会封装到一个AggregateException对象中待回调都执行完后返回，其InnerExceptions属性包含了所有异常的详细信息
        - 给CancellationToken对象的ManualResetEvent对象Set()信号

   2. CancellationToken相关API

      ```
      // 传播有关应取消操作的通知。
      public struct CancellationToken
      {
          public CancellationToken(bool canceled);
          public static CancellationToken None { get; }
       
          // 获取此标记是否能处于已取消状态。
          public bool CanBeCanceled { get; }
          // 获取是否已请求取消此标记。
          public bool IsCancellationRequested { get; }
       
          // 获取内部ManualResetEvent，在CancellationTokenSource执行Cancel()时收到set()通知。
          public WaitHandle WaitHandle{ get; }
       
          // 注册一个将在取消此CancellationToken时调用的委托。
          // 参数:useSynchronizationContext:
          //一个布尔值，该值指示是否捕获当前SynchronizationContext并在调用 callback 时使用它。
          public CancellationTokenRegistration Register(Action<object> callback, object state, bool useSynchronizationContext);
       
          // 如果已请求取消此标记，则引发OperationCanceledException。
          public void ThrowIfCancellationRequested();
          ……
      }
      ```

      - CancellationToken是结构struct，值类型

      - CancellationTokenSource与CancellationToken关联是“一一对应”的

        - 无论CancellationTokenSource是通过构造函数创建还是CreateLinkedTokenSource()方法创建，与之对应的CancellationToken只有一个
        - 每个CancellationToken都会包含一个私有字段，保存唯一与之对应的CancellationTokenSource引用

      - CancellationToken实例的None属性与参数不是true的CancellationToken构造函数。它们返回一个特殊的CancellationToken实例，该实例不与任何CancellationTokenSource实例关联(即不可能调用Cancel())，其CanBeCanceled实例属性为false

      - CancellationToken的Register()方法返回的CancellationTokenRegistration对象，可调用其Dispose()方法删除一个Register()登记的回调方法

      - CancellationToken实例的WaitHandle属性：会先判断若没有对应的CancellationTokenSource，则创建一个默认的CancellationTokenSource对象。然后再判断若没有内部事件等待句柄则new ManualResetEvent(false)，在CancellationTokenSource执行Cancel()时收到set()通知。

      -  CancellationToken实例的ThrowIfCancellationRequested()方法如下:

        ```
        public void ThrowIfCancellationRequested()
        {
            if (this.IsCancellationRequested)
            {
                throw new OperationCanceledException(
                Environment.GetResourceString("OperationCanceled"), this);
            }
        }
        ```

   3. 示例**(见示例：AsyncCancellationToken4_1)**

2. SpinWait结构----自旋等待

   一个轻量同步类型(结构体)，提供对基于自旋的等待的支持。

   SpinWait只有在多核处理器下才具有使用意义。在单处理器下，自旋转会占据CPU时间，却做不了任何事。

   ```
   public struct SpinWait
   {
       // 获取已对此实例调用SpinWait.SpinOnce() 的次数。
       public int Count { get; }
       // 判断对SpinWait.SpinOnce() 的下一次调用是否触发上下文切换和内核转换。
       public bool NextSpinWillYield { get; }
    
       // 重置自旋计数器。
       public void Reset();
       // 执行单一自旋。
       public void SpinOnce();
       // 在指定条件得到满足(Func<bool>委托返回true)之前自旋。
       public static void SpinUntil(Func<bool> condition);
       // 在指定条件得到满足或指定超时过期之前自旋。参数condition为在返回 true 之前重复执行的委托。
       // 返回结果:
       // 如果条件在超时时间内得到满足，则为 true；否则为 false
       public static bool SpinUntil(Func<bool> condition, int millisecondsTimeout);
       public static bool SpinUntil(Func<bool> condition, TimeSpan timeout);
   }
   ```

   - SpinWait自旋转是调用Thread.SpinWait

   - 由NextSpinWillYield属性代码可知，若SpinWait运行在单核计算机上，它总是进行上下文切换（让出处理器）

   - SpinWait不仅仅是一个空循环。它经过了精心实现，可以针对一般情况提供正确的旋转行为以避免内核事件所需的高开销的上下文切换和内核转换；在旋转时间足够长的情况下自行启动上下文切换，SpinWait甚至还会在多核计算机上产生线程的时间片（Thread.Yield()）以防止等待线程阻塞高优先级的线程或垃圾回收器线程

   - SpinOnce()自旋一定次数后可能导致**频繁**上下文切换。注意只有等待时间非常短时，SpinOnce()或SpinUntil()提供的智能行为才会获得更好的效率，否则您应该在SpinWait自行启动上下文切换之前调用自己的内核等待。

   - 通常使用SpinWait来封装自己“两阶段等待操作”，避免内核事件所需的高开销的上下文切换和内核转换。

     实现自己的“两阶段等待操作”：

     ```
     if (!spinner.NextSpinWillYield)
     	{spinner.SpinOnce();}
     else
     	{自己的事件等待句柄;}
     ```

3. SpinLock结构----自旋锁

   






















