---
typora-copy-images-to: MarkDownPics
---

异步编程系列文章5：《异步编程：.NET4.X 数据并行》
http://www.cnblogs.com/heyuquan/archive/2013/03/13/2958092.html

**任务并行库 (TPL)** 是 .NET Framework 4的 System.Threading 和 System.Threading.Tasks 命名空间中的一组公共类型和 API。

> TPL的目的在于简化向应用程序中添加并行性和并发性的过程，从而提高开发人员的工作效率。
>
> TPL会动态地按比例调节并发程度，以便最有效地使用所有可用的处理器。
>
> TPL还处理工作分区、ThreadPool 上的线程调度、取消支持、状态管理以及其他低级别的细节操作。

从 .NET Framework 4 开始，TPL 是编写多线程代码和并行代码的首选方法。

本主题分两部分讲解：

> [《异步编程：.NET4.X任务并行》](http://www.cnblogs.com/heyuquan/archive/2013/04/18/3028044.html#task)，下节Task里讲解  
>
> [《异步编程：.NET4.X ](http://www.cnblogs.com/heyuquan/archive/2013/03/13/2958092.html)[数据并行》](http://www.cnblogs.com/heyuquan/archive/2013/03/13/2958092.html)，本节所述内容

### 一、并发与并行 

1. 并发与并行的区别：

   （借用甘特图来帮助我们更清晰地知道多任务的运行情况，常用的甘特图软件有：GanttProject 、翰文横道图编制系统、Microsoft Office Project）

   - 并发：一个处理器在“同一时段（时间间隔）”处理多个任务，各个任务之间快速交替执行。如图：

     ![1553853616558](MarkDownPics\1553853616558.png)

   - 并行：多个处理器或者多核的处理器“同一时刻（时间点）”处理多个不同的任务。并行是真正的细粒度上的同时进行，既同一时间点上同时发生着多个并发。并行一定是并发，而并发不一定是并行。如图：

     ![1553853742919](MarkDownPics\1553853742919.png)

### 二、数据并行

数据并行是指对源集合或数组中的元素同时（即并行）执行相同操作的情况。

> 先稍微了解下Action和Func委托，此两委托由微软提供；Action是一个没有返回参数的委托，Func是一个有返回值的委托。

1. 并行循环

   当并行循环运行时，TPL会将数据源按照内置的分区算法（或者你可以自定义一个分区算法）**将数据划分为多个不相交的子集**，然后，从线程池中选择线程并行地处理这些数据子集，**每个线程只负责处理一个数据子集**。在后台，任务计划程序将根据系统资源和工作负荷来对任务进行分区。如有可能，计划程序会在工作负荷变得不平衡的情况下在多个线程和处理器之间重新分配工作。

   在对任何代码（包括循环）进行并行化时，一个重要的目标是利用尽可能多的处理器，但不要过度并行化到使行处理的开销让任何性能优势消耗殆尽的程度。比如：对于嵌套循环，只会对外部循环进行并行化。

   由于循环体是并行运行的，迭代范围的分区是根据可用的逻辑内核数、分区大小以及其他因素动态变化的，因此**无法保证迭代的执行顺序**。

   - Parallel.For

     为固定数目的独立For循环迭代提供了**负载均衡的潜在并行执行**。Parallel内部通过**RangeManger对象**实现负载均衡。

     > 负载均衡的执行会尝试将工作分发在不同的任务中，这样所有的任务在大部分时间内部可以保持繁忙。负载均衡总是试图减少任务的闲置时间。

     ```
     public static ParallelLoopResult For(int fromInclusive, int toExclusive
         , ParallelOptions parallelOptions, Action<int, ParallelLoopState> body);
         
     // 执行具有线程本地数据的 for 循环，泛型类型参数TLocal为本地线程数据类型。
     public static ParallelLoopResult For<TLocal>(int fromInclusive, int toExclusive
         , ParallelOptions parallelOptions
         , Func<TLocal> localInit
         , Func<int, ParallelLoopState, TLocal, TLocal> body
         , Action<TLocal> localFinally
         );
     ```

     1. 返回ParallelLoopResult结构

        System.Threading.Tasks.ParallelLoopResult是**结构体**，当所有线程均已完成时，For 将返回 ParallelLoopResult 对象。若你手动停止或中断循环迭代时，此返回值特别有用，因为 **ParallelLoopResult 存储诸如完成运行的最后一个迭代"等"信息**。

        ```
        public struct ParallelLoopResult
        {
            // 获取该循环是否已运行完成。
            public bool IsCompleted { get; }
            // 获取从中调用 ParallelLoopState.Break() 的最低迭代的索引。
            public long? LowestBreakIteration { get; }
        }
        ```

        - 如果 IsCompleted 返回 true，该循环的所有迭代均已执行，并且该循环没有收到提前结束的请求.
        -  如果 IsCompleted 返回 false：
          - LowestBreakIteration 返回 null，则为调用 ParallelLoopState.Stop() 提前结束循环。
          - LowestBreakIteration 返回非 null 整数值，则为调用 ParallelLoopState.Break() 提前结束循环。

     2. 迭代范围

        对于迭代范围（fromInclusive<= x <toExclusive）中的每个值调用一次body委托。如果 fromInclusive 大于或等于 toExclusive，则该方法立即返回，而无需执行任何迭代。

     3. ParallelOptions类型

        - ParallelOptions实例存储用于配置 Parallel 类的方法的操作的选项。

          ```
          public class ParallelOptions 
          {
              public ParallelOptions();
              // 获取或设置与此 ParallelOptions 实例关联的 CancellationToken。
              public CancellationToken CancellationToken { get; set; }
              // 获取或设置此 ParallelOptions 实例所允许的最大并行度。
              public int MaxDegreeOfParallelism { get; set; }
              // 获取或设置与此 ParallelOptions 实例关联的 TaskScheduler。
              public TaskScheduler TaskScheduler { get; set; }
          }
          ```

          - 提供一个无参数的构造函数，此构造函数使用默认值初始化实例。MaxDegreeOfParallelism 初始化为 -1，表示并行量没有上限设置；CancellationToken 初始化为CancellationToken.None不可取消的标记；TaskScheduler 初始化为默认计划程序 (TaskScheduler.Default)。

          - 指定最大并行度

            有时候，你并不希望在并行循环中使用所有的内核，因为你对剩余的内核有特定的需求和更好的使用计划。

            通常指定Environment.ProcessorCount，或者是根据此值计算出来的值（eg：Environment.ProcessorCount-1）。默认情况下，如果没有指定最大并行度，TPL就会允许通过启发式算法提高或降低线程的数目，通常这样会高于ProcessorCount，因为这样可以更好地支持CPU和I/O混合型的工作负荷。

     4. ParallelLoopState类型

        可用来使 Tasks.Parallel 循环的迭代与其他迭代交互，并为 Parallel 类的循环提供提前退出循环的功能。**此类的实例不要自行创建，它由 Parallel 类创建并提供给每个循环项，并且只应该在提供此实例的“循环内部”使用。** 























